1Ô∏è‚É£ What exactly is an API in a web app?

Think of a web app in three layers:

Frontend (React/HTML/JS)  <--->  Backend (Django/Python)  <--->  Database (MySQL/PostgreSQL)


The Database stores your data (students, results, users).

The Backend contains the logic (how to save, read, update, delete data).

The Frontend displays data and interacts with users.

API = the messenger between frontend and backend

It is NOT the database, and it is NOT Axios.
It is the interface (or endpoint) your frontend calls to get or send data.

Example:

Your React app wants a list of students.

It sends a request to your backend:

GET http://localhost:8000/api/students/


The backend receives the request, queries the database, and sends JSON data back.

Here, the API is the URL + the backend logic that handles the request.
So:

http://localhost:8000/api/students/ ‚Üí the API endpoint

Django REST Framework helps you build this endpoint easily.

2Ô∏è‚É£ What is REST then?

REST (Representational State Transfer) is a set of rules to design APIs:

Use HTTP methods to describe actions:

GET ‚Üí read data

POST ‚Üí create data

PUT/PATCH ‚Üí update data

DELETE ‚Üí delete data

Resources are accessed via URLs:

/api/students/ ‚Üí all students

/api/students/1/ ‚Üí student with ID 1

REST is a design style. The API is the actual endpoint you call.

3Ô∏è‚É£ Do you have to write ‚Äú/api/‚Äù in URLs?

No ‚ú® ‚Äî it is just a convention, not mandatory.

Many developers use /api/ to clearly separate API endpoints from normal web pages.

You could name your URL anything: /students/, /v1/students/, /users/ ‚Äî it doesn‚Äôt matter as long as it‚Äôs consistent.

Example in urls.py:

from rest_framework.routers import DefaultRouter
from .views import StudentViewSet

router = DefaultRouter()
router.register(r'students', StudentViewSet)
urlpatterns = router.urls


Here, /students/ is enough. Adding /api/ is just to make it clear:

/api/students/

4Ô∏è‚É£ Where does Axios fit in?

Axios is how the frontend talks to the API.

Example:

axios.get("http://localhost:8000/api/students/")
  .then(response => console.log(response.data));


Axios just sends the HTTP request; the API receives it and responds with JSON.

üîë Visual analogy:
Frontend (React)   ---Axios--->   API (Django REST endpoint)   ---queries---> Database
      |                                     |
      |<---------JSON Response-------------|


Frontend: wants data

API (endpoint): gives data

Database: stores data

So API = the part in the backend that the frontend calls, and REST = how the API is designed.

1Ô∏è‚É£ The r in r'students'

r means raw string, and it mostly affects backslashes.

In Python, a normal string interprets \ as an escape:

# Normal string
s = "Hello\nWorld"
print(s)
# Output:
# Hello
# World  (because \n = newline)


Raw string:

s = r"Hello\nWorld"
print(s)
# Output:
# Hello\nWorld  (backslash is treated literally)


In URLs like 'students', there are no backslashes, so r is actually not necessary.

‚úÖ Using r or not here makes no difference:

router.register(r'students', StudentViewSet)
router.register('students', StudentViewSet)  # exactly the same


Use r only if your string has backslashes, like regex patterns.

2Ô∏è‚É£ StudentViewSet and how it works

You wrote you‚Äôre confused because your StudentViewSet has:

queryset = Student.objects.all()
serializer_class = StudentSerializer


Let‚Äôs break it:

a) queryset = Student.objects.all()

queryset tells the ViewSet which data to work with.

Example: Student.objects.all() ‚Üí ‚ÄúI want all Student records in the database.‚Äù

When a router receives a request:

GET /students/ ‚Üí calls list() method ‚Üí uses queryset to return all students.

GET /students/1/ ‚Üí calls retrieve() ‚Üí uses queryset to find student with id=1.

DELETE /students/1/ ‚Üí uses queryset to find the student to delete.

So queryset = data source.

b) serializer_class = StudentSerializer

serializer_class tells the ViewSet how to convert the data:

Python objects (Student instances) ‚Üí JSON (for API response)

JSON ‚Üí Python objects (when creating/updating via POST/PUT)

Example:

# Student model instance
student = Student(name="Siti", age=20)

# Serializer
serializer = StudentSerializer(student)
serializer.data
# Output: {'id': 1, 'name': 'Siti', 'age': 20}


So when someone does GET /students/, the ViewSet:

Gets queryset ‚Üí all students

Passes each student to StudentSerializer ‚Üí converts to JSON

Returns JSON to the client

When someone does POST /students/ with JSON data:

{"name": "Ali", "age": 18}


ViewSet uses serializer_class to validate JSON

Creates a new Student in the database

‚úÖ Summary

r'students' ‚Üí optional, just a string for URL prefix

StudentViewSet ‚Üí contains logic for all actions

queryset ‚Üí which data the ViewSet operates on

serializer_class ‚Üí how to convert Python objects ‚Üî JSON

All of this together allows the router to:

Generate URLs automatically

Map HTTP methods (GET, POST, PUT, DELETE) ‚Üí ViewSet actions (list, create, update, destroy)

Handle data using queryset and serializer_class

üß© 1. What is APIView?

APIView is a base class provided by DRF to help you manually define how your API should behave.
It gives you full control ‚Äî but you have to write more code.

Example:

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Student
from .serializers import StudentSerializer

class StudentAPIView(APIView):
    def get(self, request):
        students = Student.objects.all()
        serializer = StudentSerializer(students, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = StudentSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


‚úÖ Pros:

Gives you full control (you can customize every method).

Great for learning how DRF works internally.

‚ùå Cons:

More boilerplate (repeated code for CRUD operations).

‚öôÔ∏è 2. What is ModelViewSet?

ModelViewSet is a shortcut or higher-level abstraction built on top of APIView.
It automatically provides all CRUD operations for your model:

GET (list and retrieve)

POST (create)

PUT / PATCH (update)

DELETE (destroy)

Example:

from rest_framework import viewsets
from .models import Student
from .serializers import StudentSerializer

class StudentViewSet(viewsets.ModelViewSet):
    queryset = Student.objects.all()
    serializer_class = StudentSerializer


That‚Äôs it!
This small code automatically gives you endpoints for listing, creating, updating, deleting, and retrieving students.

‚úÖ Pros:

Very little code.

Built-in CRUD operations.

Easy to connect with DRF‚Äôs routers (for automatic URLs).

‚ùå Cons:

Less flexible if you want completely custom behavior.

üì¶ 3. What is serializer_class = StudentSerializer?

A serializer converts complex data (like Django models) into JSON (or other formats) that can be sent over an API ‚Äî and vice versa.

Example:

from rest_framework import serializers
from .models import Student

class StudentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Student
        fields = '__all__'


Here:

The serializer takes a Student model instance and turns it into JSON.

It also validates and converts incoming JSON back into a Student instance.

So when you write:

serializer_class = StudentSerializer


You‚Äôre telling the ViewSet:
üëâ ‚ÄúWhen you send or receive data, use this serializer to handle it.‚Äù

üß† Summary:
Concept	Purpose	Example
APIView	Manually define how GET, POST, etc. behave.	class StudentAPIView(APIView): ...
ModelViewSet	Auto CRUD operations for a model.	class StudentViewSet(viewsets.ModelViewSet): ...
serializer_class	Converts between Django models ‚Üî JSON.	serializer_class = StudentSerializer
