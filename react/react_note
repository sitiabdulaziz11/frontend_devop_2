What are Vite and Create React App (CRA)?

These are React project builders (or â€œbundlersâ€) that help you create and run React apps easily.

They are frontend tools, while Express is backend.

Letâ€™s compare them clearly ğŸ‘‡

Feature	Vite âš¡	Create React App (CRA) ğŸ§±
Creator	Made by Evan You (Vueâ€™s creator)	Made by Facebook
Speed	Very fast startup and builds	Slower, older setup
Command to create project	npm create vite@latest my-app -- --template react	npx create-react-app my-app
Run command	npm run dev	npm start
Config file	vite.config.js	No config (hidden)
Recommended in 2025?	âœ… Yes (modern & fast)	âš ï¸ Older, rarely used now
ğŸ§© 3ï¸âƒ£ When and why to use each
ğŸŸ© Vite (recommended for new React projects)

Use this when:

Youâ€™re starting a new React project.

You want fast reloads and modern setup.

You donâ€™t want heavy configurations.

ğŸª„ Example:

npm create vite@latest my-react-app -- --template react
cd my-react-app
npm install
npm run dev


Then open http://localhost:5173

ğŸŸ¦ Create React App (CRA)

Use this when:

You are working on an older tutorial or legacy project.

You need something that already comes with react-scripts.

ğŸª„ Example:

npx create-react-app my-react-app
cd my-react-app
npm start


Then open http://localhost:3000

ğŸ§± 4ï¸âƒ£ How to setup Express + React (Vite) together

Hereâ€™s the clean modern setup:

my-project/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ package.json   (Express app)
â”‚   â””â”€â”€ server.js
â”‚
â””â”€â”€ frontend/
    â”œâ”€â”€ package.json   (React app)
    â””â”€â”€ src/

Step 1: Backend (Express)
mkdir my-project
cd my-project
mkdir backend
cd backend
npm init -y
npm install express


Create server.js:

import express from "express";
const app = express();
app.get("/", (req, res) => res.send("Hello from Express!"));
app.listen(5000, () => console.log("Server running on port 5000"));


Run it:

node server.js

Step 2: Frontend (React with Vite)

From the same my-project folder:

npm create vite@latest frontend -- --template react
cd frontend
npm install
npm run dev


Now:

React frontend runs on port 5173

Express backend runs on port 5000

You can later connect them using Axios:

axios.get('http://localhost:5000/')

âœ… Summary
Tool	Purpose	Command	Used For
Express	Backend (server/API)	npm init -y && npm install express	Serve data, handle routes
Vite	Frontend (React app builder)	npm create vite@latest myapp -- --template react	Build and run modern React apps
CRA	Frontend (React app builder, older)	npx create-react-app myapp	Older tutorials or compatibility

Open your package.json and look under "dependencies" and "devDependencies".

ğŸ”¸ If you see this:
"devDependencies": {
  "vite": "^5.0.0"
}


or

"dependencies": {
  "@vitejs/plugin-react": "^4.0.0"
}


âœ… That means your project uses Vite â†’
You should have this script section:

"scripts": {
  "dev": "vite",
  "build": "vite build",
  "preview": "vite preview"
}


You start it with:

npm run dev

ğŸ”¹ If you see this:
"dependencies": {
  "react-scripts": "5.0.1"
}


âœ… That means your project uses Create React App (CRA) â†’
You should have:

"scripts": {
  "start": "react-scripts start",
  "build": "react-scripts build",
  "test": "react-scripts test",
  "eject": "react-scripts eject"
}


You start it with:

npm start

ğŸŸ¨ 2ï¸âƒ£ Check how the project was created

If you used:

npm create vite@latest my-app -- --template react


â†’ Itâ€™s Vite.

If you used:

npx create-react-app my-app


â†’ Itâ€™s Create React App (CRA).

ğŸŸ¦ 3ï¸âƒ£ Check your folder structure (optional clue)
Tool	Typical Folder Structure
Vite	Has vite.config.js or vite.config.ts
CRA	Has no vite.config.js, but includes a public/ and src/ folder with a react-scripts dependency


integrate your Django REST Framework (DRF) backend with a React frontend using Vite step by step. 

1ï¸âƒ£ Make sure your DRF backend is running

Your backend API (DRF) is running at:

http://127.0.0.1:8000/api/students/


Test it in the browser â€” you should see the list of students in JSON.

2ï¸âƒ£ Install and setup CORS in Django

By default, your React app (localhost:5173) is a different origin, so you need CORS headers.

Install django-cors-headers:

pip install django-cors-headers


Add it to INSTALLED_APPS in settings.py:

INSTALLED_APPS = [
    ...
    'corsheaders',
]


Add middleware at the top of MIDDLEWARE in settings.py:

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]


Allow your frontend origin:

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite dev server
]


âš ï¸ For development only! For production, youâ€™ll need to configure the actual domain.

Create a Vite + React app
npm create vite@latest frontend -- --template react
cd frontend
npm install
npm run dev


Your dev server will usually run on http://localhost:5173/.

Open this URL in your browser â€” you should see the React starter page.

4ï¸âƒ£ Create a service file for API calls

frontend/src/services/studentService.js

import axios from "axios";

const API_URL = "http://127.0.0.1:8000/api/students/";

export const getStudents = () => axios.get(API_URL);

export const createStudent = (student) => axios.post(API_URL, student);

export const updateStudent = (id, student) =>
  axios.put(`${API_URL}${id}/`, student);

export const deleteStudent = (id) => axios.delete(`${API_URL}${id}/`);

Use API in a React component

frontend/src/App.jsx

import React, { useEffect, useState } from "react";
import { getStudents, createStudent, updateStudent, deleteStudent } from "./services/studentService";

function App() {
  const [students, setStudents] = useState([]);
  const [name, setName] = useState("");
  const [age, setAge] = useState("");
  const [grade, setGrade] = useState("");

  useEffect(() => {
    fetchStudents();
  }, []);

  const fetchStudents = async () => {
    try {
      const response = await getStudents();
      setStudents(response.data);
    } catch (error) {
      console.error(error);
    }
  };

  const handleAddStudent = async () => {
    if (!name || !age || !grade) return;
    await createStudent({ name, age, grade });
    setName(""); setAge(""); setGrade("");
    fetchStudents();
  };

  const handleDeleteStudent = async (id) => {
    await deleteStudent(id);
    fetchStudents();
  };

  return (
    <div>
      <h1>Students</h1>
      <input placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} />
      <input placeholder="Age" value={age} onChange={(e) => setAge(e.target.value)} />
      <input placeholder="Grade" value={grade} onChange={(e) => setGrade(e.target.value)} />
      <button onClick={handleAddStudent}>Add Student</button>

      <ul>
        {students.map((student) => (
          <li key={student.id}>
            {student.name} ({student.age}, {student.grade})
            <button onClick={() => handleDeleteStudent(student.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

6ï¸âƒ£ export default App;

Run the React frontend
npm run dev



Open http://localhost:5173/

You can add, view, and delete students directly in React.

All changes are synced with your DRF backend.


Components, Props, State, Events, and JSX
1ï¸âƒ£ Components and Props

components, JSX & State

Building User interface with components
Using , sharing & outputing data
handling user events
building interface UIs with State

componenets are just a javascript function which are UI building blocks.
any website or app can be droken down into smaller duilding blocks: called components.



why components:
components are :-
- reusable building blocks
- related code live together
- seperation of concerns

component function must follow two rules:
  1 function name must start with capital letter 

  2 return renderable content,means display on screen by React.

  to create component:
  create regular js function, give it a suitable name that start with uppercase character and return some jsx code.

  npm install
  npm run dev

  jsx extention allows developers to describe and creat HTML element by writing HTML murkap code inside of javascript files.

  but jsx is not supported by browther



Components are reusable building blocks that return UI (written in JSX).

Two main types:

Function Components â†’ the modern standard.

Class Components â†’ older style.

Props (short for â€œpropertiesâ€) are how you pass data from parent â†’ child components.

Props are read-only â€” they cannot be modified inside the child.

ğŸ“˜ Example:

function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

export default function App() {
  return <Welcome name="Siti" />;
}

Welcome is a child component.

Its job: define how to display a greeting.

It takes props as input (like function arguments) so it can be reusable.

Example: You could use <Welcome name="Alice" /> or <Welcome name="Bob" />â€”the same component, different data.

App is the main (parent) component.

Its job: put together your UI.

Here it is calling the Welcome component and passing "Siti" as a prop.

2ï¸âƒ£ State (useState)

State is data that can change during the componentâ€™s life.

To use it, import the useState hook from React.

When state updates, the component re-renders.

ğŸ“˜ Example:

import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </>
  );
}

When the parent sends data (a prop) to a child component,
that data is not allowed to be changed inside the child.

Example:

function Welcome(props) {
  // âŒ This is NOT allowed:
  props.name = "Eliyas"; // âŒ Error or bad practice
  return <h1>Hello, {props.name}!</h1>;
}

export default function App() {
  return <Welcome name="Siti" />;
}


Even if you try to change props.name to "Eliyas", React wonâ€™t let you â€” because props belong to the parent.

âœ… Correct way: use state if you want to change something

If you want to update or change a value inside a component,
you should use state (useState), not props.

Example:

import { useState } from "react";

function Welcome({ name }) {
  const [newName, setNewName] = useState(name);

  function changeName() {
    setNewName("Eliyas");
  }

  return (
    <>
      <h1>Hello, {newName}!</h1>
      <button onClick={changeName}>Change to Eliyas</button>
    </>
  );
}

export default function App() {
  return <Welcome name="Siti" />;
}


âœ… What happens here:

App sends name="Siti" as a prop.

The child (Welcome) saves that into state (newName).

When you click the button, it changes state, not the original prop.

React re-renders and shows â€œEliyasâ€.

const [newName, setNewName] = useState(name);
Hereâ€™s whatâ€™s happening:

useState(name) â†’ creates a state variable inside your component, and gives it an initial value equal to the name prop (here itâ€™s "Siti").

It returns two things:

newName â†’ the current value of the state.

setNewName â†’ a function you use to change that value.

So in short:

Code	Meaning
newName	The data stored in state (starts as "Siti")
setNewName("Eliyas")	Tells React: â€œUpdate the value and re-render the component.â€

ğŸ’¡ You canâ€™t change newName directly like newName = "Eliyas" â€” React wonâ€™t detect the change.
Thatâ€™s why you must use setNewName(...).


âš–ï¸ Analogy

Think of props like a gift from your parent â€” you can use it,
but you shouldnâ€™t change it directly.

If you want something different, you can make your own copy (state)
and modify that.

const [newName, setNewName] = useState(name);
Hereâ€™s whatâ€™s happening:

useState(name) â†’ creates a state variable inside your component, and gives it an initial value equal to the name prop (here itâ€™s "Siti").

It returns two things:

newName â†’ the current value of the state.

setNewName â†’ a function you use to change that value.

So in short:

Code	Meaning
newName	The data stored in state (starts as "Siti")
setNewName("Eliyas")	Tells React: â€œUpdate the value and re-render the component.â€

ğŸ’¡ You canâ€™t change newName directly like newName = "Eliyas" â€” React wonâ€™t detect the change.
Thatâ€™s why you must use setNewName(...).


Summary

Concept	Description
Props	Data sent from parent â†’ child
Read-only	Cannot be changed directly
If need to change	Use useState in child
Why	Keeps data flow predictable (one direction)




3ï¸âƒ£ Handling Events (onClick, onChange, etc.)

React uses camelCase for events.

You pass a function, not a string (like in plain HTML).

ğŸ“˜ Example:

function Button() {
  function handleClick() {
    alert("Button clicked!");
  }

  return <button onClick={handleClick}>Click me</button>;
}


ğŸ“˜ Example with input:

function InputBox() {
  const [text, setText] = useState("");

  return (
    <input
      type="text"
      value={text}
      onChange={(e) => setText(e.target.value)}
      placeholder="Type something"
    />
  );
}

4ï¸âƒ£ JSX Syntax

JSX = JavaScript + XML â†’ lets you write HTML inside JavaScript.

You can embed variables or expressions inside {}.

Components must return one parent element (like <div> or <>).

Use className instead of class.

ğŸ“˜ Example:

const name = "Siti";
const element = <h1>Hello, {name}!</h1>;

Quick Quiz (10 Questions)

1. What does JSX stand for?
a. JavaScript XML 
b. JSON Syntax
c. Java Extended Syntax
d. JS Extension

2. Which hook lets you add state to a function component?
a. useEffect
b. useState 
c. useReducer
d. useContext

3. What keyword do you use to pass data into a child component?
a. attributes
b. props 
c. state
d. params

4. Props are:
a. Mutable
b. Immutable 
c. Both
d. None

5. What happens when you call the setState (or setCount) function?
a. Page reloads
b. Component re-renders 
c. Nothing
d. Error occurs

6. Whatâ€™s the correct event name for a button click in React?
a. onclick
b. clickEvent
c. onClick 
d. Onclick

7. JSX expressions must be wrapped in:
a. Curly braces {} 
b. Quotes ""
c. Parentheses ()
d. None

8. In React, you must use ______ instead of class for styling.
a. css
b. style
c. className 
d. classid

9. If you want to display a list of components, what must you add to each child?
a. key 
b. id
c. index
d. data-id

10. The onChange event is used mostly with:
a. Buttons
b. Inputs 
c. Links
d. Images

answer:
JavaScript XML
useState
props
Immutable
Component re-renders 
onClick
  
  Curly braces {}
className
 key
Inputs


In normal JavaScript

You call a function like this:

function greet(name) {
  return "Hello " + name;
}

console.log(greet("Siti")); // calling directly


âœ… Here, youâ€™re calling it manually with parentheses.

ğŸ’¡ In React

You donâ€™t usually call components directly like Welcome("Siti").
Instead, you use JSX syntax:

<Welcome name="Siti" />


That looks like HTML, but itâ€™s actually JavaScript under the hood.

ğŸ” What really happens behind the scenes

When React sees <Welcome name="Siti" />,
it automatically calls the function for you â€” like this:

Welcome({ name: "Siti" })


and then takes whatever it returns (usually JSX) and adds it to the page.

So this:

<Welcome name="Siti" />


is just a React-friendly shorthand for this:

React.createElement(Welcome, { name: "Siti" });

ğŸ§  Think of it like this:
What you write	What React does internally
<Welcome name="Siti" />	Welcome({ name: "Siti" })
<button onClick={handleClick}>	Binds function reference handleClick
<div>Hello</div>	React.createElement('div', null, 'Hello')

UI stands for User Interface.

ğŸ‘‰ In simple words, UI is everything the user sees and interacts with on the screen â€” buttons, text, images, input boxes, menus, etc.

So when we say:

â€œApp is the main (parent) component. Its job: put together your UI.â€

It means the App component is responsible for combining and displaying all the visible parts of your application â€” for example:

function App() {
  return (
    <div>
      <Header />
      <Welcome name="Siti" />
      <Footer />
    </div>
  );
}


Here:

Header, Welcome, and Footer are smaller UI components.

The App component puts them together to form the full User Interface (what the user sees on the page).